
T227：
  算术表达式的题：双栈。单栈法。算级优先表（这种我觉得有点复杂了，暂时不考虑）。
  双栈法： 运算符栈，字符串栈。
  ··遇到数字入栈s1。遇到运算符op时。当op比栈顶的运算符优先级高时，op入栈s2。
  当op 比 栈顶的运算符优先级低时。栈s2中运算符要先弹出来，计算值v，v再入栈s1。


  ——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
  其中单栈法：我觉得不如双栈法快。
  是把表达式先转成后缀表示法：在转换的时候用到栈来暂时存储运算符。然后再利用后缀表示结合栈来算。
  具体思路的例子：首先：中缀转后缀：
- 数字直接输出到后缀表达式
- 栈为空时，遇到运算符，直接入栈
- 遇到运算符，弹出所有优先级大于或等于该运算符的栈顶元素，并将该运算符入栈
- 将栈中元素依次出栈
  然后：计算后缀
- 遇到数字，入栈
- 遇到运算符，弹出栈顶两个元素，做运算，并将结果入栈
- 重复上述步骤，直到表达式最右端
  
  ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
  一些解释与介绍。（可忽略）
  在解析常规的算术表达式时，最麻烦的问题是每个运算符优先级不同，有时还带有括号，比如在解析3 + 4 * 2的时候，读取完3+4并不能马上计算结果，
  还要查看 4 后面的运算符优先级，如果大于前一个算符的优先级，就要先计算优先级较高的4*2，然后计算3 + 8。（为了存储3 + 这个等待解析的表达
  式，我们使用两个栈：运算符栈和运算数栈。利用栈天然的后入先出特性。
  
  我自己的想法：就是加一些判断，然后把每一个因子都存储到栈里面，最后遍历栈，然后求和。这样求出来是不对的。


T279：平方数的和
  
  注意平方的时候，不能用算法里面的根号，指针的界限可以用 i*i<= m
  想到这个动态规划了，但是有一个地方没考虑清楚。就是怎么判断到没到这个平方数。所以一直很郁闷，然后转成回溯。
  其实不应该这么想，应该先想一下，dp[剩余的数] 。这个表到底怎么填。因为是平方数的时候该填什么。
  
  这个地方比较难想的是 dp[i]的时候初始是i
  
 T283： 移动零
    这个题是简单题。但是我本来想的是找到一个0,然后开始往后遍历，进行交换。这种复杂度太高。双指针对我来说需要注意，所以我标注下来。
    优化：维持一个指针，它初始化为0，然后在遍历的时候指向非零元素索引遇到非零的时候，进行交换，并且同时让这个指针++，i++。如果是零的话只让i++。这个想法应该是很好想的。
      相当于是维持一个为0的位置，作为一个空洞
    再优化：维持快慢指针，快指针不断找非零元素，慢指针就指向0元素的左边界一直不停换。
      这个题里面的满指针就是I
    ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
    解析：（不懂的时候可以看）
              
    0 1 0 3 2 
     low=0 fast
    fast++ 然后fast指向的是非0
     fast和low交换。10032 low++ fast++
    low=1 fast=2
    fast指向【2】位置的0 。fast再去找非零
    low=1 fast=3
    13002
    low =2 fast=4
    13200
    low 总是零的左边界然后跟找到的非零进行交换，这样就会不断让非零向左移动

    整个过程：
     0 1 0 3 2 —— 1 0 0 3 2 ——1 3 0 0 2 ——1 3 2 0 0 

 T 287 ：
      我自己一直想用位运算做，结果推了半天根本就不行。异或是满足交换律，但是不适合用在这儿。还想到那个叫什么同归于尽法，也不行。
      ——————————————————————————————————————————————————————————————————————————————————————————————————————————————
      学到一个新词：鸽子洞原理（抽屉原理），，这个题解转成循环不知道跟鸽子洞有个毛线关系啊？？
        查鸽子洞的时候就发现一些可能可以用到的原理：对任何非空有限实数集合来说，最大值最起码是平均值。
     ——————————————————————————————————————————————————————————————————————————————————————————————————————————————
     判重问题常见：
      ：1、哈希表判重，2、再说排序以后相邻元素相等即找到的重复；3、桶排序；4、二分法。
      然后分析一下这些方法的时间复杂度、空间复杂度，做一个简单比较。
      ——————————————————————————————————————————————————————————————————————————————————————————————————————————————
     这里绝妙的手法：
      另外有一种不常用的：其实是把判重问题转成找循环：
      这种找环的方法有一个名字叫：循环检测法
      
      这个题解：最经典的是把这个问题转成了链表问题找环问题，链表找环的原理：当fast和low在环上相遇的时候，fast正好比low多跑了一个环的长度，
      而且fast速度是low 的两倍 就说明这时候   环长度=非环长度+相遇点距离环入口的间隔 在环里面fast跑的距离=low的距离。所以剩下的距离=非环长度
      
      还要注意的是这个题需要从Nums[1]开始，不能让low fast初始化为0.也不能初始化为1
      代码：
       # 把nums看成是顺序存储的链表，nums中每个元素的值是下一个链表节点的地址
        # 那么如果nums有重复值，说明链表存在环，本问题就转化为了找链表中环的入口节点，因此可以用快慢指针解决     
        # 初始时，都指向链表第一个节点nums[0]
        slow, fast = 0, 0
        # 慢指针走一步，快指针走两步
        slow, fast = nums[slow], nums[nums[fast]]
        # 循环退出时，slow与fast相遇，相遇节点必在环中
        while slow != fast:
            slow, fast = nums[slow], nums[nums[fast]]
        # 让before，after分别指向链表开始节点，相遇节点
        before, after = 0, slow
        # before与after相遇时，相遇点就是环的入口节点
        while before != after:
            before, after = nums[before], nums[after]         
        return before
      
 T :细胞存活这个题，有点复杂，之后再看，然后补上
     
 T300 ：最长上升子序列
 ————————————————————————————————————————————————————————————————————————————————————————————————
 瞎想阶段
      用partiton找位置，看位置有多少递增的，但是这样没有意义啊，因为还得看哪个大哪个小
      分治：（类似于希尔排序）看两个内部是不是递增，再合并的时候比较是不是递增，但是这样复杂度也不小
——————————————————————————————————————————————————————————————————————————————————————————————————
有丢丢思路：
      n^2复杂度：从右开始遍历，看当前值的之前有比它小的值，然后交换最小值。从这个值开始遍历看之前比它小的值是什么，不断交换
                这种方法要不断找一直到0.所以是n^2
                
      想办法优化：dp 
              状态：当前i位置之前的最长子序列。（也可以看做是以I位置结束的最长子序列是什么）最后发现dp[i]一定是以i结尾，不是0-i的子序列
              状态转移：状态转移是需要结合暴力用自顶向下来推的，不是从自底向上想的
              dp[i]=max(dp[<i的数])+1     发现这样复杂度并不是nlogn。是o(n^2)，问题出在找这个max上面？
              最后的结果是：max(dp),不是dp[n]。也考虑到了
     优化：（看了题解确定是这样的dp之后，自己想优化）
            想到可以记录下来当前递增子序列的末尾值或者较小的那个值。但是怎么也想不通，因为记录递增子序列的话，还是要比较。而且并不是越小越好，
            这里就忽略了一点：可以记录长度相同的递增序列的末尾值中的最小值。所以就是忽略了一点没有想到记录长度相同的递增序列！！！！！！
     题解的优化：
          把状态改变了，反过来记录作为dp[i]
          本来找nums[i]递增序列最大长度：dp[i] 到I的最大长度
          现在反其道：dp[i]记录I长度的递增子序列的末尾值的最小值。因为越小越容易被递增。
          ps :自己的瞎想
          （问题是，我觉得这个状态方程不好推，如果是10,9,2,5,3,7,1
          dp[0]=1，但是1在最右，那dp[2]只能在1的右侧找比1大的数，吗？这样说明我认为的状态方程不对。）
          
          所以正在dp[i]状态没这么简单：是在I之前的所有最长子序列是i的最小值。不是说在整个nums里面。
          
          （注意推状态方程的时候，多用暴力生成几个，到比较中间的位置推会比较好想）
          
          二分求第一个大于nums[i]的值的时候，注意应该dp里面找第一个大于等于的值。也就是>=的时候，让搜索空间左移。之所以能用二分是因为dp是递增的。
            
          参考：https://github.com/liweiwei1419/LeetCode-Solution-Well-Formed
          leetcode题解
          https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/
              
 T 326 ：看数是不是3的幂
    循环的方法比较简单。比较少见的是硬编码的形式：
    
    
 T 350：数组的交集
      自己的思路：用map来统计一下出现的数字。但是我想不通的一点就是有的出现的次数不同。单纯看是不是map会不会出现不行，得看个数。
      而且不知道，这个最后的结果怎么弄
      ——————————————————————————————————————————————————————————————————————————————————————————————————————————————
      从这个题学到的东西：
           再遍历map的时候来--。map里面为正数的时候，就往nums1里面赋值最后的结果，最后再返回vector的前k个，这个还是很有技巧性的。 
      注意这个题虽然是一个简单题，但是这个题值得再看看
        
