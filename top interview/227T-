
T227：
  算术表达式的题：双栈。单栈法。算级优先表（这种我觉得有点复杂了，暂时不考虑）。
  双栈法： 运算符栈，字符串栈。
  ··遇到数字入栈s1。遇到运算符op时。当op比栈顶的运算符优先级高时，op入栈s2。
  当op 比 栈顶的运算符优先级低时。栈s2中运算符要先弹出来，计算值v，v再入栈s1。


  ——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
  其中单栈法：我觉得不如双栈法快。
  是把表达式先转成后缀表示法：在转换的时候用到栈来暂时存储运算符。然后再利用后缀表示结合栈来算。
  具体思路的例子：首先：中缀转后缀：
- 数字直接输出到后缀表达式
- 栈为空时，遇到运算符，直接入栈
- 遇到运算符，弹出所有优先级大于或等于该运算符的栈顶元素，并将该运算符入栈
- 将栈中元素依次出栈
  然后：计算后缀
- 遇到数字，入栈
- 遇到运算符，弹出栈顶两个元素，做运算，并将结果入栈
- 重复上述步骤，直到表达式最右端
  
  ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
  一些解释与介绍。（可忽略）
  在解析常规的算术表达式时，最麻烦的问题是每个运算符优先级不同，有时还带有括号，比如在解析3 + 4 * 2的时候，读取完3+4并不能马上计算结果，
  还要查看 4 后面的运算符优先级，如果大于前一个算符的优先级，就要先计算优先级较高的4*2，然后计算3 + 8。（为了存储3 + 这个等待解析的表达
  式，我们使用两个栈：运算符栈和运算数栈。利用栈天然的后入先出特性。
  
  我自己的想法：就是加一些判断，然后把每一个因子都存储到栈里面，最后遍历栈，然后求和。这样求出来是不对的。


T279：平方数的和
  
  注意平方的时候，不能用算法里面的根号，指针的界限可以用 i*i<= m
  想到这个动态规划了，但是有一个地方没考虑清楚。就是怎么判断到没到这个平方数。所以一直很郁闷，然后转成回溯。
  其实不应该这么想，应该先想一下，dp[剩余的数] 。这个表到底怎么填。因为是平方数的时候该填什么。
  
  这个地方比较难想的是 dp[i]的时候初始是i
  
 T283： 移动零
    这个题是简单题。但是我本来想的是找到一个0,然后开始往后遍历，进行交换。这种复杂度太高。双指针对我来说需要注意，所以我标注下来。
    优化：维持一个指针，它初始化为0，然后在遍历的时候指向非零元素索引遇到非零的时候，进行交换，并且同时让这个指针++，i++。如果是零的话只让i++。这个想法应该是很好想的。
      相当于是维持一个为0的位置，作为一个空洞
    再优化：维持快慢指针，快指针不断找非零元素，慢指针就指向0元素的左边界一直不停换。
      这个题里面的满指针就是I
    ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
    解析：（不懂的时候可以看）
              
    0 1 0 3 2 
     low=0 fast
    fast++ 然后fast指向的是非0
     fast和low交换。10032 low++ fast++
    low=1 fast=2
    fast指向【2】位置的0 。fast再去找非零
    low=1 fast=3
    13002
    low =2 fast=4
    13200
    low 总是零的左边界然后跟找到的非零进行交换，这样就会不断让非零向左移动

    整个过程：
     0 1 0 3 2 —— 1 0 0 3 2 ——1 3 0 0 2 ——1 3 2 0 0 

 T 287 ：
      我自己一直想用位运算做，结果推了半天根本就不行。异或是满足交换律，但是不适合用在这儿。还想到那个叫什么同归于尽法，也不行。
      ——————————————————————————————————————————————————————————————————————————————————————————————————————————————
      学到一个新词：鸽子洞原理（抽屉原理），，这个题解转成循环不知道跟鸽子洞有个毛线关系啊？？
        查鸽子洞的时候就发现一些可能可以用到的原理：对任何非空有限实数集合来说，最大值最起码是平均值。
     ——————————————————————————————————————————————————————————————————————————————————————————————————————————————
     判重问题常见：
      ：1、哈希表判重，2、再说排序以后相邻元素相等即找到的重复；3、桶排序；4、二分法。
      然后分析一下这些方法的时间复杂度、空间复杂度，做一个简单比较。
      ——————————————————————————————————————————————————————————————————————————————————————————————————————————————
     这里绝妙的手法：
      另外有一种不常用的：其实是把判重问题转成找循环：
      这种找环的方法有一个名字叫：循环检测法
      
      这个题解：最经典的是把这个问题转成了链表问题找环问题，链表找环的原理：当fast和low在环上相遇的时候，fast正好比low多跑了一个环的长度，
      而且fast速度是low 的两倍 就说明这时候   环长度=非环长度+相遇点距离环入口的间隔 在环里面fast跑的距离=low的距离。所以剩下的距离=非环长度
      
      还要注意的是这个题需要从Nums[1]开始，不能让low fast初始化为0.也不能初始化为1
      代码：
       # 把nums看成是顺序存储的链表，nums中每个元素的值是下一个链表节点的地址
        # 那么如果nums有重复值，说明链表存在环，本问题就转化为了找链表中环的入口节点，因此可以用快慢指针解决     
        # 初始时，都指向链表第一个节点nums[0]
        slow, fast = 0, 0
        # 慢指针走一步，快指针走两步
        slow, fast = nums[slow], nums[nums[fast]]
        # 循环退出时，slow与fast相遇，相遇节点必在环中
        while slow != fast:
            slow, fast = nums[slow], nums[nums[fast]]
        # 让before，after分别指向链表开始节点，相遇节点
        before, after = 0, slow
        # before与after相遇时，相遇点就是环的入口节点
        while before != after:
            before, after = nums[before], nums[after]         
        return before
      
      
      
