
T227：
  算术表达式的题：双栈。单栈法。算级优先表（这种我觉得有点复杂了，暂时不考虑）。
  双栈法： 运算符栈，字符串栈。
  ··遇到数字入栈s1。遇到运算符op时。当op比栈顶的运算符优先级高时，op入栈s2。
  当op 比 栈顶的运算符优先级低时。栈s2中运算符要先弹出来，计算值v，v再入栈s1。


  ——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
  其中单栈法：我觉得不如双栈法快。
  是把表达式先转成后缀表示法：在转换的时候用到栈来暂时存储运算符。然后再利用后缀表示结合栈来算。
  具体思路的例子：首先：中缀转后缀：
- 数字直接输出到后缀表达式
- 栈为空时，遇到运算符，直接入栈
- 遇到运算符，弹出所有优先级大于或等于该运算符的栈顶元素，并将该运算符入栈
- 将栈中元素依次出栈
  然后：计算后缀
- 遇到数字，入栈
- 遇到运算符，弹出栈顶两个元素，做运算，并将结果入栈
- 重复上述步骤，直到表达式最右端
  
  ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
  一些解释与介绍。（可忽略）
  在解析常规的算术表达式时，最麻烦的问题是每个运算符优先级不同，有时还带有括号，比如在解析3 + 4 * 2的时候，读取完3+4并不能马上计算结果，
  还要查看 4 后面的运算符优先级，如果大于前一个算符的优先级，就要先计算优先级较高的4*2，然后计算3 + 8。（为了存储3 + 这个等待解析的表达
  式，我们使用两个栈：运算符栈和运算数栈。利用栈天然的后入先出特性。
  
  我自己的想法：就是加一些判断，然后把每一个因子都存储到栈里面，最后遍历栈，然后求和。这样求出来是不对的。


T279：平方数的和
  
  注意平方的时候，不能用算法里面的根号，指针的界限可以用 i*i<= m
  想到这个动态规划了，但是有一个地方没考虑清楚。就是怎么判断到没到这个平方数。所以一直很郁闷，然后转成回溯。
  其实不应该这么想，应该先想一下，dp[剩余的数] 。这个表到底怎么填。因为是平方数的时候该填什么。
  
  这个地方比较难想的是 dp[i]的时候初始是i
  
 T283： 移动零
    这个题是简单题。但是我本来想的是找到一个0,然后开始往后遍历，进行交换。这种复杂度太高。双指针对我来说需要注意，所以我标注下来。
    优化：维持一个指针，它初始化为0，然后在遍历的时候指向非零元素索引遇到非零的时候，进行交换，并且同时让这个指针++，i++。如果是零的话只让i++。这个想法应该是很好想的。
      相当于是维持一个为0的位置，作为一个空洞
    再优化：维持快慢指针，快指针不断找非零元素，慢指针就指向0元素的左边界一直不停换。
      这个题里面的满指针就是I
    ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
    解析：（不懂的时候可以看）
              
    0 1 0 3 2 
     low=0 fast
    fast++ 然后fast指向的是非0
     fast和low交换。10032 low++ fast++
    low=1 fast=2
    fast指向【2】位置的0 。fast再去找非零
    low=1 fast=3
    13002
    low =2 fast=4
    13200
    low 总是零的左边界然后跟找到的非零进行交换，这样就会不断让非零向左移动

    整个过程：
     0 1 0 3 2 —— 1 0 0 3 2 ——1 3 0 0 2 ——1 3 2 0 0 
