T 242：异位词
  思路：用map来。还有优化：map来记录，遍历另一个来遍历对应的键值减减
  优化：直接用一个26位的词表，遍历第一个string 来对词表++，遍历第二个string 来对词表--。来看是否有字母的词表值如果有负的就说明不是异位词。

T 238：保存除Nums[i]之外元素的乘积
  思路：可以先算出所有的乘积再除，但是问题是可能有0
  优化：用两个数组，分布保存nums[i]左右所有元素的乘积。
  再优化，只用一个数组保存nums[i]左边的乘积。然后从右边开始遍历nums，用一个指针不断更新当前数组的右边的乘积。
  
T 240：二维矩阵搜索
  思路：每次比较mid,target  排除一列或者一行
        
T 268：缺失数字
  思路：求1-n的和，然后相减，最后剩余的
  优化：1-n的和，用(n-1)*n/2 会溢出。边加边减。这一点要注意。
  public:
    int missingNumber(vector<int>& nums) {
        int n=nums.size();int sum=0;
        for(int i=0;i<nums.size();i++,n--){
            sum+=n;
            sum-=nums[i];           
        }
        return sum;
    }
   
T 328 ：把奇数位置的结点放在链表前面
    这个题我觉得不难，比较需要注意的地方是：
     无指针指向的位置需要先用某一个有指针指向的结点->next先链接起来。跳出循环位置是->next 还是也需要->next->next
    还有这个题有一个技巧：
      偶数看成整体，而且整体的前面可以先不进行链接，到最后再链接。
      
      1->3->2->4->5->6:
         有 无 有 有  无
         cur   tr tmp
        所以先让tr的next指向tmp->next。这样无指针的地方才不会丢失
        然后处理tr->netx指向cur->next 这里的技巧就是：2这个位置之前的结点是一直在变的，所以暂时不连接，直到最后再链接。
      
