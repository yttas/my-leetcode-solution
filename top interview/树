T230：（求搜索树中第k个数）
      搜索树的中序：递增序列。（特点）
      ————————————————————————————————————————————————————————————————————
      固定其中一个写法。但是现在有点记不住。还有就是返回值的时候要注意return -1;
          int kthSmallest(TreeNode* root, int k) {
        stack<TreeNode*> s;
        TreeNode* cur=root;
        while(cur!=NULL || !s.empty()){
            if(cur!=NULL){
                s.push(cur);
                cur=cur->left;
            }
            else{
                cur=s.top();s.pop();
                k--;
                if(k==0){return cur->val;}
                cur=cur->right;
            }
        }
        return -1;//我这有点反应不过来。注意这个地方要有return
  
T236：
      基础：深度搜索遍历。这个需要自己再看一下。因为这个是用回溯。和之前学的也不大一样。不只是无返回值，修改一个全局。
      这个题对于判断是不是找到的方法也比较巧妙
      左子树找到其中一个。右子树找到一个，或者本身当前结点就是其中一个。只要两个都找到就是说明，当前结点是它们两个的公共结点。
      在往后递归的时候，这个公共结点会不断更新。最终会得到最近的。这种思路很难想。
      
