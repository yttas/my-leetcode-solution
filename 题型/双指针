  
    先记录一些指针的命名：m1 m2 
    
    
    
    
T 334 ：递增的三元组
    这个题：动态规划，想到了；双指针也想到了。
    但是做双指针的时候有一个疑问的地方就是：如果当前的三元组的最小值换了，那次小值和最小值之间不再是前后顺序了。然后再找出大于它们的数时还是不是递增序列
    例子：   9 6 7 2 8 
    我疑惑的地方在 本来是 6 7 现在变成了2 7 这样不就不是递增子序列了吗，因为2 7 位置反了。
    这里自己举出的反例把自己坑了。其实是只要8>7那 ，8一定大于后面那个数，不管那个数是6 还是2 都无所谓。
    而且利用if elseif的排斥特点，就是执行完If就 不再执elseif了，可以用来更新指针
    还要注意到相等的情况。等于的时候一定要替换不然【1,1,1】会返回true;
    
    学到： 我总是在一些题里面想到方法但是自己总想一些反例来否定这个方法，实际要注意这些反例的特点，这些反例有可能是解题的题眼。

    还有一种方法，感觉挺好的，虽然不符合空间复杂度为o(1)。记录一下。
    
    思路三：前后遍历
          定义两个数组forward[i]和backward[i]，forward[i]从前向后遍历，保存[0, i]之间最小元素值，backward[i]从后向前遍历，
          保存[i, size - 1]间最大元素值。然后从前向后遍历，如果找到一个数满足forward[i] < nums[i] < backward[i]，则表示三元子序列存在。
          比如：
          nums[i]: 8 3 5 1 6
          forwa[i]: 8 3 3 1 1
          backw[i]:8 6 6 6 6

          代码
          时间复杂度：O(n)
          空间复杂度：O(n)
                  for (int i = 1; i < size; ++i) {
                      f[i] = min(f[i - 1], nums[i]);
                  }
                  for (int i = size - 2; i >= 0; --i) {
                      b[i] = max(b[i + 1], nums[i]);
                  }
                  for (int i = 0; i < size; ++i) {
                      if (f[i] < nums[i] && nums[i] < b[i]) return true;
                  }
                  return false;

